package "gmlewis/io"

// Values
fn append[T](Slice[T], Slice[T]) -> Slice[T]

fn as_array_view[T](Slice[T]) -> ArrayView[T]

fn cap[T](Slice[T]) -> Int

fn copy(&Writer, &Reader) -> (Int64, IOError?)

fn copy_buffer(&Writer, &Reader, Slice[Byte]?) -> (Int64, IOError?)

fn copy_json(&ByteReader) -> (Json, Int64, IOError?)

fn copy_n(&Writer, &Reader, Int64) -> (Int64, IOError?)

fn copy_size(&Writer, &ByteReader, Int64) -> (Int64, IOError?)

fn copy_until(&Writer, &ByteReader, Byte) -> (Int64, IOError?)

let discard : Discard

fn each[T](Slice[T], (T) -> Unit) -> Unit

let eof : IOError

let err_invalid_write : IOError

let err_no_progress : IOError

let err_offset : IOError

let err_short_buffer : IOError

let err_short_write : IOError

let err_unexpected_eof : IOError

let err_whence : IOError

fn fold[A, B](Slice[A], init~ : B, (B, A) -> B) -> B

fn foldi[A, B](Slice[A], init~ : B, (Int, B, A) -> B) -> B

fn iter[A](Slice[A]) -> Iter[A]

fn iter2[A](Slice[A]) -> Iter2[Int, A]

fn length(Buffer) -> Int

fn op_as_view[T](Slice[T], start~ : Int = .., end? : Int) -> Slice[T]

fn op_get[T](Slice[T], Int) -> T

fn op_set[T](Slice[T], Int, T) -> Unit

fn push[T](Slice[T], T) -> Slice[T]

fn read_all(&Reader) -> (Slice[Byte], IOError?)

fn read_from(Buffer, &Reader) -> (Int64, IOError?)

fn read_full(&Reader, Slice[Byte]) -> (Int, IOError?)

fn reset(Buffer, size_hint~ : Int = ..) -> Unit

fn rev_fold[A, B](Slice[A], init~ : B, (B, A) -> B) -> B

fn rev_foldi[A, B](Slice[A], init~ : B, (Int, B, A) -> B) -> B

fn rev_inplace[T](Slice[T]) -> Unit

fn substring(Buffer, start~ : Int = .., end~ : Int = ..) -> String

fn swap[T](Slice[T], Int, Int) -> Unit

fn to_bytes(Buffer) -> Bytes

fn to_slice(Buffer) -> Slice[Byte]

fn write_byte(Buffer, Byte) -> (Int, IOError?)

fn write_bytes(Buffer, Bytes) -> (Int, IOError?)

fn write_string(Buffer, String) -> (Int, IOError?)

// Types and methods
type Buffer
impl Buffer {
  from_bytes(Bytes) -> Self
  from_slice(Slice[Byte]) -> Self
  from_string(String) -> Self
  length(Self) -> Int
  new(size_hint~ : Int = ..) -> Self
  op_get(Self, Int) -> Byte
  read_from(Self, &Reader) -> (Int64, IOError?)
  reset(Self, size_hint~ : Int = ..) -> Unit
  substring(Self, start~ : Int = .., end~ : Int = ..) -> String
  to_bytes(Self) -> Bytes
  to_slice(Self) -> Slice[Byte]
  write_byte(Self, Byte) -> (Int, IOError?)
  write_bytes(Self, Bytes) -> (Int, IOError?)
  write_string(Self, String) -> (Int, IOError?)
}
impl ByteReader for Buffer
impl Reader for Buffer
impl Writer for Buffer
impl Eq for Buffer
impl Show for Buffer

type Discard
impl Reader for Discard
impl Writer for Discard

pub(all) type! IOError String
impl Eq for IOError
impl Show for IOError

type LimitedReader
impl LimitedReader {
  new(&Reader, Int64) -> Self
}
impl Reader for LimitedReader

type NopCloser
impl NopCloser {
  new(&Reader) -> Self
}
impl Closer for NopCloser
impl Reader for NopCloser

type OffsetWriter
impl OffsetWriter {
  new(&WriterAt, Int64) -> Self
}

type SectionReader
impl SectionReader {
  new(&ReaderAt, Int64, Int64) -> Self
}

type Slice[T]
impl Slice {
  append[T](Self[T], Self[T]) -> Self[T]
  as_array_view[T](Self[T]) -> ArrayView[T]
  cap[T](Self[T]) -> Int
  each[T](Self[T], (T) -> Unit) -> Unit
  fold[A, B](Self[A], init~ : B, (B, A) -> B) -> B
  foldi[A, B](Self[A], init~ : B, (Int, B, A) -> B) -> B
  iter[A](Self[A]) -> Iter[A]
  iter2[A](Self[A]) -> Iter2[Int, A]
  length[T](Self[T]) -> Int
  new[T](Array[T], start~ : Int = .., end? : Int) -> Self[T]
  op_as_view[T](Self[T], start~ : Int = .., end? : Int) -> Self[T]
  op_get[T](Self[T], Int) -> T
  op_set[T](Self[T], Int, T) -> Unit
  push[T](Self[T], T) -> Self[T]
  rev_fold[A, B](Self[A], init~ : B, (B, A) -> B) -> B
  rev_foldi[A, B](Self[A], init~ : B, (Int, B, A) -> B) -> B
  rev_inplace[T](Self[T]) -> Unit
  swap[T](Self[T], Int, Int) -> Unit
  to_bytes(Self[Byte]) -> Bytes
}
impl[T : Eq] Eq for Slice[T]
impl[X : Show] Show for Slice[X]

type TeeReader
impl TeeReader {
  new(&Reader, &Writer) -> Self
}
impl Reader for TeeReader

pub(all) enum Whence {
  SeekStart
  SeekCurrent
  SeekEnd
}

// Type aliases

// Traits
pub(open) trait ByteReader {
  read_byte(Self) -> (Byte, IOError?)
}

pub(open) trait ByteScanner : ByteReader {
  unread_byte(Self) -> IOError?
}

pub(open) trait ByteWriter {
  write_byte(Self, Byte) -> IOError?
}

pub(open) trait Closer {
  close(Self) -> IOError?
}

pub(open) trait ReadCloser : Reader + Closer {
}

pub(open) trait ReadSeekCloser : Reader + Seeker + Closer {
}

pub(open) trait ReadSeeker : Reader + Seeker {
}

pub(open) trait ReadWriteCloser : Reader + Writer + Closer {
}

pub(open) trait ReadWriteSeeker : Reader + Writer + Seeker {
}

pub(open) trait ReadWriter : Reader + Writer {
}

pub(open) trait Reader {
  read(Self, Slice[Byte]) -> (Int, IOError?)
}

pub(open) trait ReaderAt {
  read_at(Self, Slice[Byte], Int64) -> (Int, IOError?)
}

pub(open) trait ReaderFrom {
  read_from(Self, &Reader) -> (Int64, IOError?)
}

pub(open) trait Seeker {
  seek(Self, Int64, Whence) -> (Int64, IOError?)
}

pub(open) trait WriteCloser : Writer + Closer {
}

pub(open) trait WriteSeeker : Writer + Seeker {
}

pub(open) trait Writer {
  write(Self, Slice[Byte]) -> (Int, IOError?)
}

pub(open) trait WriterAt {
  write_at(Self, Slice[Byte], Int64) -> (Int, IOError?)
}

pub(open) trait WriterTo {
  write_to(Self, &Writer) -> (Int64, IOError?)
}

